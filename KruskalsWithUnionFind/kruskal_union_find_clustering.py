'''
This implementation of Kruskal's algorithm generates disjoint k-clusters for the nodes in the graph (where k is the numbers of clusters). 
This approach of clustering ensures max-spacing between clusters where the spacing is defined as minimum distance between any two nodes of disjoint clusters.
The running time complexity of this algorithm is O(mlogm); m = # edges.
In this example the algorithm was executed on a graph of 500 nodes and ~125,000 edges and 200 clusters were generated. The max spacing for the graph used was 26.
Plotting the graph shows disjoint clusters generated by the algorithm.
'''

from datetime import datetime
import networkx as nx
import matplotlib.pyplot as plt
from pyvis.network import Network

class UnionFind:
    def __init__(self, nodes):
        self.__uf_sets = {node: [node] for node in nodes}
        self.__uf_ds = {node: node for node in nodes}

    def find(self, u):
        return self.__uf_ds[u]

    def union(self, a, b):
        if(len(self.__uf_sets[self.__uf_ds[a]]) >= len(self.__uf_sets[self.__uf_ds[b]])):
            self.__uf_sets[self.__uf_ds[a]] = self.__uf_sets[self.__uf_ds[a]] + self.__uf_sets[self.__uf_ds[b]]
            set_to_be_deleted = self.__uf_ds[b]
            for e in self.__uf_sets[self.__uf_ds[b]]:
                self.__uf_ds[e] = self.__uf_ds[a]
            del self.__uf_sets[set_to_be_deleted]
        else:
            self.__uf_sets[self.__uf_ds[b]] = self.__uf_sets[self.__uf_ds[b]] + self.__uf_sets[self.__uf_ds[a]]
            set_to_be_deleted = self.__uf_ds[a]
            for e in self.__uf_sets[self.__uf_ds[a]]:
                self.__uf_ds[e] = self.__uf_ds[b]            
            del self.__uf_sets[set_to_be_deleted]

    def get_uf_sets(self):
        return self.__uf_sets

def read_input_file(filename):  
    edges = []
    nodes = set()
    
    lines = open(filename)

    for line in lines:
        tokens = [int(item) for item in line.split(' ')]
        if(len(tokens) == 3):
            edges.append((tokens[0], tokens[1], tokens[2]))
            nodes.add(tokens[0])
            nodes.add(tokens[1])

    return (nodes, edges)

def plot_mst(e):
    G = nx.DiGraph(e)

    # Add labels to each node
    for node in G.nodes():
        G.nodes[node]['label'] = f'Node {node}' 

    net = Network(notebook=True, cdn_resources='remote', height="1000px", width="1000px")


    net.set_options("""
    var options = {
        "physics": {
            "enabled": true,
            "stabilization": {
                "enabled": true,
                "iterations": 500
            },
            "maxVelocity": 5
        }
    }
    """)

    net.from_nx(G)
    net.show("mst_kruskal_clusters.html")

def run_kruskals_uf(v, edges, uf):
    current_time_begin = datetime.now()
    edges = sorted(edges, key=lambda x: x[2])
    x = set()
    clusters = []

    for edge in edges:
        if(uf.find(edge[0]) != uf.find(edge[1])):
            if(len(uf.get_uf_sets().keys()) == 200):
                print('min distance edge: ', edge)
                break
            uf.union(edge[0], edge[1])
            x.add(edge[0])
            x.add(edge[1])
            clusters.append((edge[0], edge[1]))

    current_time_end = datetime.now()    
    plot_mst(clusters)

    execution_time = (current_time_end - current_time_begin).total_seconds() * 1000
    print(f"The execution time is {execution_time} milliseconds.")        

def make_union_find(nodes):
    return {node: node for node in nodes}

if __name__ == '__main__':
    nodes, edges = read_input_file('clustering1.txt')
    union_find_ds = UnionFind(nodes)
    run_kruskals_uf(nodes, edges, union_find_ds)