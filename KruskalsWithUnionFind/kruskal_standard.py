'''
Standard implementation of Kruskal's algorithm.
The running time complexity of this algorithm is O(mlogm); m = # edges.
For a graph with 500 nodes and ~125,000 edges this standard algorithm takes 865 milliseconds to execute and the optimized (union-find) algorithm 25 milliseconds.
Plotting the graph shows that the minimum spanning tree generated by this code is indeed a tree as there are no cycles in the plotted graph.
'''

from datetime import datetime
from functools import reduce
from queue import SimpleQueue
import networkx as nx
import matplotlib.pyplot as plt
from pyvis.network import Network

def build_adj_list(input_file):
    adj_lst = {}
    edges = []

    edge_file = open(input_file)

    for line in edge_file:
        edge = line.split(' ')
        edge = [int(e) for e in edge]

        if(len(edge) == 3):
            edges.append((edge[0], edge[1], edge[2]))

            if(edge[0] in adj_lst):
                adj_lst[edge[0]].append((edge[1], edge[2]))
            else:
                adj_lst[edge[0]] = [(edge[1], edge[2])] 

            if(edge[1] in adj_lst):
                adj_lst[edge[1]].append((edge[0], edge[2]))
            else:
                adj_lst[edge[1]] = [(edge[0], edge[2])]

    return (adj_lst, edges)

def read_all_edges(filename):

    edges_file = open(filename)

    edges = []
    for line in edges_file:
        line = [int(x) for x in line.split(' ')]
        if(len(line) == 3):
            edges.append((line[0],line[1],line[2]))

    return edges

#used to find cycles in the graph
def bfs_path(mst_adj_lst, u, v):
    def bfs(v, visited):
        if(q.empty()):
            return False
        
        node = q.get()

        node_c = mst_adj_lst[node]
        for c in node_c:
            if(c == v):
                return True
            else:
                if(c not in visited):
                    visited.append(c)
                    q.put(c)
        
        status = bfs(v, visited)
        return status

    if(u not in list(mst_adj_lst.keys())):
        return False
    
    q = SimpleQueue()
    q.put(u)
    return bfs(v,[u])

def plot_mst(e):
    G = nx.DiGraph(e)

    # Add labels to each node
    for node in G.nodes():
        G.nodes[node]['label'] = f'Node {node}' 

    net = Network(notebook=True, cdn_resources='remote')

    net.set_options("""
    var options = {
        "physics": {
            "enabled": true,
            "stabilization": {
                "enabled": true,
                "iterations": 500
            },
            "maxVelocity": 5
        }
    }
    """)

    net.from_nx(G)
    net.show("mst_kruskal_standard.html")

def run_kruskals(adj_lst, edges):
    current_time_begin = datetime.now()
    if(len(edges) == 0):
        print('empty tree')
        return
    
    if(len(edges) == 1):
        print('cost: ', edges[0][2])
    
    edges = sorted(edges, key=lambda x: x[2])
    v = set(list(adj_lst.keys()))
    x = set()
    cost = edges[0][2]
    mst_adj_lst = {edges[0][0]: [edges[0][1]],edges[0][1]: [edges[0][0]]}
    x.add(edges[0][0])
    x.add(edges[0][1])
    mst_edges = [(edges[0][0], edges[0][1])]

    for edge in edges[1:]:
        if(x == v):
            break

        if(not bfs_path(mst_adj_lst, edge[0], edge[1])):
            cost += edge[2]
            x.add(edge[0])
            x.add(edge[1])

            if(edge[0] in list(mst_adj_lst.keys())):
                mst_adj_lst[edge[0]].append(edge[1])
            else:
                mst_adj_lst[edge[0]] = [edge[1]]

            if(edge[1] in list(mst_adj_lst.keys())):
                mst_adj_lst[edge[1]].append(edge[0])
            else:
                mst_adj_lst[edge[1]] = [edge[0]]

            mst_edges.append((edge[0], edge[1]))

    current_time_end = datetime.now()

    print('#nodes in MST: ', len(x))
    print('#edges in MST: ' , len(mst_edges))
    print('MST cost: ', cost)
    plot_mst(mst_edges)

    execution_time = (current_time_end - current_time_begin).total_seconds() * 1000
    print(f"The execution time is {execution_time} milliseconds.")    

if __name__ == '__main__':
    adj_lst, edges = build_adj_list('clustering1.txt')
    run_kruskals(adj_lst, edges)